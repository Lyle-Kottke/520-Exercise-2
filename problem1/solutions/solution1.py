def solve(m: int, x: int) -> int:
    """
    Calculates the minimum number of traps required to catch the x-mouse.

    The mouse moves from room i to i * x (mod m). The total number of rooms is m,
    and GCD(x, m) = 1.

    The minimum number of traps is equal to the total number of distinct orbits
    generated by the transformation f(i) = i * x (mod m).

    The rooms are partitioned into:
    1. The trivial orbit {0} of size 1. (Requires 1 trap)
    2. Non-zero orbits {1, ..., m-1}, all of which have the same size k, where
       k is the order of x modulo m (ord_m(x)).

    The total number of traps is 1 + (m - 1) / k.

    :param m: The number of rooms (2 <= m <= 10^14).
    :param x: The parameter for the mouse's movement (1 <= x < m, GCD(x, m) = 1).
    :return: The minimum number of traps.
    """

    def prime_factorize(n):
        """Returns a list of unique prime factors of n."""
        factors = set()
        d = 2
        temp = n
        while d * d <= temp:
            if temp % d == 0:
                factors.add(d)
                while temp % d == 0:
                    temp //= d
            d += 1
        if temp > 1:
            factors.add(temp)
        return list(factors)

    def power(base, exp, mod):
        """Calculates (base^exp) % mod efficiently."""
        res = 1
        base %= mod
        while exp > 0:
            if exp % 2 == 1:
                res = (res * base) % mod
            base = (base * base) % mod
            exp //= 2
        return res

    def euler_phi(n, unique_primes=None):
        """Calculates Euler's totient function phi(n)."""
        if n == 1:
            return 1
        if unique_primes is None:
            unique_primes = prime_factorize(n)

        result = n
        for p in unique_primes:
            result = result // p * (p - 1)
        return result

    # --- Step 1 & 2: Handle room 0 and trivial case ---
    if m == 2: # Rooms 0, 1. x=1. k=1. N = 1 + (2-1)/1 = 2.
        return 2

    # --- Step 3: Find the order of x modulo m, k = ord_m(x) ---
    
    # 3a. Calculate phi(m)
    m_primes = prime_factorize(m)
    phi_m = euler_phi(m, m_primes)

    # 3b. Find prime factors of phi(m)
    phi_m_primes = prime_factorize(phi_m)
    
    # The order k is a divisor of phi_m. We find it by checking if x^ (phi_m / p)
    # is 1 (mod m) for each prime factor p of phi_m. If it is 1, then the order 
    # must divide phi_m / p, so we reduce phi_m.
    k = phi_m
    
    for p in phi_m_primes:
        # p is a prime factor of the current k
        while k % p == 0:
            candidate_k = k // p
            if power(x, candidate_k, m) == 1:
                k = candidate_k
            else:
                # p is a necessary factor in the order k, so stop dividing by p
                break
                
    # --- Step 4: Final calculation ---
    # Total traps = 1 (for room 0) + (m - 1) / k (for non-zero rooms)
    # Since k is the order of x mod m, (m - 1) must be divisible by k.
    
    return 1 + (m - 1) // k
